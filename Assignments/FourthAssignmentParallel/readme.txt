Per analizzare il costo di ogni parte del programma ho sviluppato una versione sequenziale del programma e misurato il costo in millisecondi per ogni filtro (metodo SequentialTwoStage() della classe) tramite la libreria chrono. Ho subito notato come il costo del Gaussian filter fosse molto più basso rispetto al Sobel filter. Il punto critico (collo di bottiglia) di questo programma è senza dubbio la computazione del Sobel filter. Ho ipotizzato a uno scheletro dell'applicazione che bilanciasse il numero di thread per il calcolo del Sobel filter e Gaussian. L'idea era quella di implementare due farm (una per il calcolo del Gaussian e l'altra per il Sobel) che presentano un numero di worker bilanciato (quindi nel nostro caso la farm del calcolo del Sobel presenterà un numero di worker molto superiore rispetto a quella per il calcolo del Gaussian). Queste due farm (prima Gaussian e Sobel) comunicherebbero tramite una coda che distribuisce poi alla seconda farm le immagini dove viene poi eseguito il filtro Sobel. Tuttavia non avendo a disposizione FastFlow ho sviluppato due versioni parallele che eseguono entrambi filtri uno dopo l'altro. La prima utilizza gli standard thread e la seconda con OpenMp (utilizzando lo schedule dynamic).

Il programma presenta un main file (main.cpp) dove viene importato il file ImageProcessing.h contenente la classe ImageProcessing . Compilando il main tramite gcc e passando tramite linea di comando i parametri PercorsoCartella WorkerNumbersr multiplyWork il programma stampa in output la quantità di  tempo, in millisecondi, utilizzato per applicare il Sobel e il Gaussian filter per ogni immagine.  

All'interno della cartella benchmark sono presenti i dati ottenuti sullo Xeon-Phi, il programma è stato testato con 300 immagini sulla versione di OpenMP e standard C++ threads. Per queste due configurazioni sono presenti  i tempi impiegati dal programma e i grafici di speedup e scalability al variare del numero di worker (da 1 a 256) all'interno della cartella /benchmark. Per ogni grafico è presente una versione zommata chiamata *_zoom.png . 

Il codice prodotto è inoltre disponibile online al seguente link:  https://github.com/FraCorti/PSD-assignments/tree/master/FourthAssignmentParallel. Per eseguire il codice sullo Xeon-Phi è sufficiente dare da linea di comando: "g++ -std=c++17 -O3 -finline-functions -I /home/marcod/opencv4/include/opencv4 -L /home/marcod/opencv4/lib main.cpp -o main -lopencv_core -lopencv_imgproc -lopencv_imgcodecs -fopenmp -pthread". Il comando genererà un file main eseguibile dando da linea di comando: "./main /home/marcod/brina 1 10". Il programma esegue in ordine la versione sequenziale, quella parallela con OpenMp e infine quella parallela con gli standard thread. Per ognuna della versioni vengono stampati i tempi (in millisecondi). 
